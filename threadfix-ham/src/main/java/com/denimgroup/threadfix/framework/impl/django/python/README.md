
     Copyright (C) 2017 Applied Visions - http://securedecisions.com

     The contents of this file are subject to the Mozilla Public License
     Version 2.0 (the "License"); you may not use this file except in
     compliance with the License. You may obtain a copy of the License at
     http://www.mozilla.org/MPL/

     Software distributed under the License is distributed on an "AS IS"
     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
     License for the specific language governing rights and limitations
     under the License.

     This material is based on research sponsored by the Department of Homeland
     Security (DHS) Science and Technology Directorate, Cyber Security Division
     (DHS S&T/CSD) via contract number HHSP233201600058C.

Django endpoint detection makes use of a custom, partial Python interpreter. This
interpreter is designed to execute Python where not all dependencies or symbols
can be resolved.

The interpreter consists of the following core parts:
1. Schema parser `PythonSyntaxParser`; _Collects class and method declarations, decorators, and variable declarations into `AbstractPythonStatement` types_
2. Expression parser `PythonExpressionParser`; _Constructs_ expression trees based on a string of Python code into `PythonExpression` types
3. Interpreter `PythonInterpreter`; Executes and resolves dependencies of `PythonExpressions`, delegates to `ExpressionInterpreter` types based on the expressions to be interpreted
4. Runtime values of type `PythonValue`; Represents any runtime type such as an expression, Python Array, Python Object, etc.
5. Indeterminate Values and Expressions; `PythonValue` types that indicate an operation that either had unresolved dependencies or unsupported code

##### Schema Parser

This is used to gather types and their locations, along with other metadata. When executing Python code, this metadata is
used to resolve function calls to their declaring file and start/end lines. Variable dependencies
and class base types can be resolved without executing the associated code.

##### Expression Parser

Python code strings are compiled to an expression tree for execution by the `PythonInterpreter`. This class
will determine expression types and attempt to resolve value literals such as Strings and Arrays. Value literals
are generated by the `PythonValueBuilder`.

The expression parser supports:
- Direct array indexers `pyArray[x]`
- Data literals: arrays, sets, tuples, maps, strings, numerics
- Primitive operations: Assignment, concatenation
- Function calls
- Member accessors

##### PythonInterpreter

Provides an interface for running Python code strings, source code, and raw expressions. Maintains
an `ExecutionContext` stack which retains variable values as the interpreter executes code. The interpreter
delegates execution to implementors of `ExpressionInterpreter`. Each `PythonExpressions` type is capable of
providing an `ExpressionInterpreter` type that is capable of interpreting the associated expression.

##### PythonValue

Various implementors of `PythonValue` may be returned by the `PythonInterpreter` as the result of evaluating
an expression.

##### Indeterminate Values and Expressions

Processing involving any Indeterminate type will result in either a no-op or return `PythonIndeterminateValue`. This enables
execution regardless of whether all symbols were successfully resolved.

------

The `PythonInterpreter` can be seen in use by the `DjangoEndpointGenerator`.